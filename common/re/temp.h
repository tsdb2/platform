#ifndef __TSDB2_COMMON_RE_TEMP_H__
#define __TSDB2_COMMON_RE_TEMP_H__

#include <cstdint>
#include <optional>
#include <utility>
#include <vector>

#include "absl/container/btree_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/status/statusor.h"
#include "common/re/automaton.h"
#include "common/re/capture_groups.h"
#include "common/re/dfa.h"
#include "common/re/nfa.h"
#include "common/reffed_ptr.h"

namespace tsdb2 {
namespace common {
namespace regexp_internal {

using Assertions = AbstractAutomaton::Assertions;
using StateSet = NFA::StateSet;
using State = NFA::State;

// Represents an NFA under construction.
//
// `TempNFA` is used by the `Parser` to perform various manipulations during construction.
class TempNFA final {
 public:
  using States = absl::btree_map<uint32_t, State>;

  // TESTS ONLY: force `Finalize()` to always generate an NFA even if it's deterministic. Defaults
  // to false.
  static bool force_nfa_for_testing;

  explicit TempNFA() = default;

  explicit TempNFA(States states, uint32_t const initial_state, uint32_t const final_state)
      : states_(std::move(states)), initial_state_(initial_state), final_state_(final_state) {}

  ~TempNFA() = default;

  TempNFA(TempNFA const &) = default;
  TempNFA &operator=(TempNFA const &) = default;
  TempNFA(TempNFA &&) noexcept = default;
  TempNFA &operator=(TempNFA &&) noexcept = default;

  uint32_t initial_state() const { return initial_state_; }
  uint32_t final_state() const { return final_state_; }

  // Checks if the automaton is deterministic (that is, for each state each label is at most on one
  // edge and either there's no epsilon-move or the epsilon-move is the only edge).
  bool IsDeterministic() const;

  // Renames state `old_name` to `new_name`, updating the whole graph and doing the necessary
  // merges.
  //
  // The operation is not possible if the two states exist and belong to different capture groups,
  // so in that case `RenameState` doesn't change anything and returns false.
  bool RenameState(uint32_t old_name, uint32_t new_name);

  // Renames all states of this NFA so that they are greater than or equal to `next_state`. The
  // `next_state` variable is incremented accordingly.
  void RenameAllStates(uint32_t *next_state);

  // Adds a new edge labeled with character `label` from state `from` to state `to`.
  //
  // REQUIRES: states `from` and `to` must be present in the automaton.
  void AddEdge(char label, uint32_t from, uint32_t to);

  // Adds a new epsilon-edge from state `from` to state `to` only if `from != to`.
  //
  // REQUIRES: states `from` and `to` must be present in the automaton.
  void MaybeAddEpsilonEdge(uint32_t const from, uint32_t const to) {
    if (from != to) {
      AddEdge(0, from, to);
    }
  }

  // Chains this NFA with `other` by merging the final state of the former with the initial state of
  // the latter. The resulting automaton recognizes concatenations of the strings originally
  // recognized by `this` and those originally recognized by `other`.
  //
  // WARNING: this method will NOT rename states as necessary to avoid collisions; the caller is
  // responsible for calling `RenameAllStates` beforehand.
  TempNFA &Chain(TempNFA other);

  // Merges `other` with this automaton, resulting in a new automaton that accepts both languages.
  // `initial_state` and `final_state` must be newly generated by the caller.
  void Merge(TempNFA &&other, int capture_group, uint32_t initial_state, uint32_t final_state);

  // Finalizes this automaton by converting it into a `DFA` object if it's deterministic or an `NFA`
  // if it's not.
  absl::StatusOr<reffed_ptr<AbstractAutomaton>> Finalize(CaptureGroups capture_groups) &&;

 private:
  // Implements the `HasDeadEnds` method (see below for more information).
  //
  // A dead end is an epsilon-loop with no exits, so our implementation simply checks the parent NFA
  // for epsilon-loops and every time it finds one it checks whether it has exits (i.e. non-epsilon
  // outbound edges). The boolean value returned by `Run` is true iff there's at least one dead end,
  // in which case the compilation of the whole regular expression should fail.
  class DeadEndChecker final {
   public:
    explicit DeadEndChecker(TempNFA const &parent) : parent_(parent) {}

    ~DeadEndChecker() = default;

    bool Run() &&;

   private:
    class StateFrame final {
     public:
      static std::optional<StateFrame> Create(DeadEndChecker *const parent, uint32_t const state) {
        if (parent->PushState(state)) {
          return StateFrame(parent, state);
        } else {
          return std::nullopt;
        }
      }

      StateFrame(StateFrame &&other) noexcept : parent_(other.parent_), state_(other.state_) {
        other.parent_ = nullptr;
      }

      ~StateFrame() {
        if (parent_ != nullptr) {
          parent_->PopState(state_);
        }
      }

     private:
      explicit StateFrame(DeadEndChecker *const parent, uint32_t const state)
          : parent_(parent), state_(state) {}

      StateFrame(StateFrame const &) = delete;
      StateFrame &operator=(StateFrame const &) = delete;
      StateFrame &operator=(StateFrame &&) = delete;

      DeadEndChecker *parent_;
      uint32_t state_;
    };

    DeadEndChecker(DeadEndChecker const &) = delete;
    DeadEndChecker &operator=(DeadEndChecker const &) = delete;
    DeadEndChecker(DeadEndChecker &&) = delete;
    DeadEndChecker &operator=(DeadEndChecker &&) = delete;

    bool PushState(uint32_t state);
    void PopState(uint32_t state);

    // Checks whether the current `path_` has any exits, i.e. non-epsilon outbound edges.
    bool HasExits(uint32_t last_state) const;

    // Checks whether the epsilon-graph rooted at this node has any dead ends.
    bool IsDeadEnd(uint32_t state);

    TempNFA const &parent_;
    absl::flat_hash_set<uint32_t> visited_;
    absl::flat_hash_set<uint32_t> path_set_;
    std::vector<uint32_t> path_;
  };

  // Adds a state and its edges to the NFA, or merges it with an existing one.
  //
  // REQUIRES: if state `state_num` exists it must belong to the same capture group as `state`.
  void MergeState(uint32_t state_num, State &&new_state);

  // Auxiliary method for the implementation of `CollapseEpsilonMoves`.
  bool CollapseNextEpsilonMove();

  // Collapses epsilon-moves by merging states that are separated by such a move.
  //
  // REQUIRES: the automaton must be deterministic, in which case two states separated by an
  // epsilon-move can't have any other edge in between.
  void CollapseEpsilonMoves();

  // Checks the automaton for so-called "dead ends", i.e. epsilon-loops with no exits (no outbound
  // non-epsilon edges). Such loops are problematic because they don't consume any input character,
  // so they would always cause a DFA to loop indefinitely and would sometimes also prevent NFAs
  // from terminating. If our automaton has one or more dead ends we must fail compilation of the
  // regular expression.
  bool HasDeadEnds() const { return DeadEndChecker(*this).Run(); }

  // Finalizes this NFA by converting it to an `DFA` object, assuming the automaton is deterministic
  // (`IsDeterministic()` must return true) and has no epsilon-moves (`CollapseEpsilonMoves()` must
  // have been called).
  reffed_ptr<DFA> ToDFA(CaptureGroups capture_groups) &&;

  // Finalizes this NFA by converting it to an `NFA` object.
  reffed_ptr<NFA> ToNFA(CaptureGroups capture_groups) &&;

  States states_;
  uint32_t initial_state_ = 0;
  uint32_t final_state_ = 0;
};

}  // namespace regexp_internal
}  // namespace common
}  // namespace tsdb2

#endif  // __TSDB2_COMMON_RE_TEMP_H__
