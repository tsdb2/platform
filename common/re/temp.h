#ifndef __TSDB2_COMMON_RE_TEMP_H__
#define __TSDB2_COMMON_RE_TEMP_H__

#include <cstddef>
#include <cstdint>
#include <memory>

#include "absl/container/btree_map.h"
#include "common/re/automaton.h"
#include "common/re/dfa.h"
#include "common/re/nfa.h"
#include "common/reffed_ptr.h"

namespace tsdb2 {
namespace common {
namespace regexp_internal {

using Assertions = AbstractAutomaton::Assertions;
using StateSet = NFA::StateSet;
using State = NFA::State;

// Represents an NFA under construction.
//
// `TempNFA` is used by the `Parser` to perform various manipulations during construction.
class TempNFA final {
 public:
  using States = absl::btree_map<uint32_t, State>;

  // TESTS ONLY: force `Finalize()` to always generate an NFA even if it's deterministic. Defaults
  // to false.
  static bool force_nfa_for_testing;

  explicit TempNFA() = default;

  explicit TempNFA(States states, uint32_t const initial_state, uint32_t const final_state)
      : states_(std::move(states)), initial_state_(initial_state), final_state_(final_state) {}

  TempNFA(TempNFA const &) = default;
  TempNFA &operator=(TempNFA const &) = default;
  TempNFA(TempNFA &&) noexcept = default;
  TempNFA &operator=(TempNFA &&) noexcept = default;

  uint32_t initial_state() const { return initial_state_; }
  uint32_t final_state() const { return final_state_; }

  // Checks if the automaton is deterministic (that is, for each state each label is at most on one
  // edge and either there's no epsilon-move or the epsilon-move is the only one).
  bool IsDeterministic() const;

  // Renames state `old_name` to `new_name`, updating the whole graph and doing the necessary
  // merges.
  //
  // The operation is not possible if the two states exist and belong to different capture groups,
  // so in that case `RenameState` doesn't change anything and returns false.
  bool RenameState(uint32_t old_name, uint32_t new_name);

  // Renames all states of this NFA so that they are greater than or equal to `next_state`. The
  // `next_state` variable is incremented accordingly.
  void RenameAllStates(uint32_t *next_state);

  // Adds a new edge labeled with character `label` from state `from` to state `to`.
  //
  // REQUIRES: states `from` and `to` must be present in the automaton.
  void AddEdge(char label, uint32_t from, uint32_t to);

  // Adds a new epsilon-edge from state `from` to state `to` only if `from != to`.
  //
  // REQUIRES: states `from` and `to` must be present in the automaton.
  void MaybeAddEpsilonEdge(uint32_t const from, uint32_t const to) {
    if (from != to) {
      AddEdge(0, from, to);
    }
  }

  // Chains this NFA with `other` by merging the final state of the former with the initial state of
  // the latter. The resulting automaton recognizes concatenations of the strings originally
  // recognized by `this` and those originally recognized by `other`.
  //
  // WARNING: this method will NOT rename states as necessary to avoid collisions; the caller is
  // responsible for calling `RenameAllStates` beforehand.
  TempNFA &Chain(TempNFA other);

  // Merges `other` with this automaton, resulting in a new automaton that accepts both languages.
  // `initial_state` and `final_state` must be newly generated by the caller.
  void Merge(TempNFA &&other, int capture_group, uint32_t initial_state, uint32_t final_state);

  // Finalizes this automaton by converting it into a `DFA` object if it's deterministic or an `NFA`
  // if it's not.
  reffed_ptr<AbstractAutomaton> Finalize(CaptureGroups capture_groups) &&;

 private:
  // Adds a state and its edges to the NFA, or merges it with an existing one.
  //
  // REQUIRES: if state `state_num` exists it must belong to the same capture group as `state`.
  void MergeState(uint32_t state_num, State &&new_state);

  // Auxiliary method for the implementation of `CollapseEpsilonMoves`.
  bool CollapseNextEpsilonMove();

  // Collapses epsilon-moves by merging states that are separated by such a move.
  //
  // REQUIRES: the automaton must be deterministic, in which case two states separated by an
  // epsilon-move can't have any other edge in between.
  void CollapseEpsilonMoves();

  // Finalizes this NFA by converting it to an `DFA` object, assuming the automaton is deterministic
  // (`IsDeterministic()` must return true) and has no epsilon-moves (`CollapseEpsilonMoves()` must
  // have been called).
  reffed_ptr<DFA> ToDFA(CaptureGroups capture_groups) &&;

  // Finalizes this NFA by converting it to an `NFA` object.
  reffed_ptr<NFA> ToNFA(CaptureGroups capture_groups) &&;

  States states_;
  uint32_t initial_state_ = 0;
  uint32_t final_state_ = 0;
};

}  // namespace regexp_internal
}  // namespace common
}  // namespace tsdb2

#endif  // __TSDB2_COMMON_RE_TEMP_H__
